// Generated by CoffeeScript 1.9.1
(function() {
  var AUTO, AsyncProxyPool, GLOBAL_TIMEOUT, IMPLICIT, MAX_REQUEST_IN_TRANSACTION, NEW, Promise, Request, SUB, TICKER_REPEAT, Transaction, _, psbytes, ref;

  Promise = require('bluebird');

  _ = require('lodash');

  Request = require('./request');

  psbytes = Promise.promisify(require('crypto').pseudoRandomBytes);

  ref = require('./constants'), NEW = ref.NEW, SUB = ref.SUB, AUTO = ref.AUTO, IMPLICIT = ref.IMPLICIT, GLOBAL_TIMEOUT = ref.GLOBAL_TIMEOUT, MAX_REQUEST_IN_TRANSACTION = ref.MAX_REQUEST_IN_TRANSACTION, TICKER_REPEAT = ref.TICKER_REPEAT;

  AsyncProxyPool = require('async-proxy-pool');

  Transaction = (function() {
    var deathticks, transactionTicker;

    Transaction.processing = {};

    Transaction.implicit = [];

    Transaction.unanswered = [];

    function Transaction(arg) {
      this.callback = arg.callback, this.name = arg.name, this.adapter = arg.adapter, this.id = arg.id;
      this.state = 'initial';
      this.subtransactions = [];
      this._client = null;
      this.isSubtransaction = false;
    }

    Transaction.prototype.start = function(transactionType) {
      var self;
      self = this;
      return Promise.resolve(this.name).then(function(name) {
        if (name) {
          return name;
        }
        return psbytes(12).then(function(buf) {
          return buf.toString('base64');
        });
      }).then(function(name) {
        Transaction.logger.debug("START", name.slice(0, 4));
        self.name = name;
        switch (transactionType) {
          case IMPLICIT:
            return self.startImplicit();
          case NEW:
            return self.create();
          case AUTO:
            return self.createAutocommit();
          case transactionType instanceof Transaction:
            return self.merge(transactionType);
          default:
            throw new Error("unknown transaction type " + transactionType);
        }
      })["catch"](function(err) {
        Transaction.logger.error("error during transaction " + self.name + ": " + err);
        throw err;
      });
    };

    Transaction.prototype.startImplicit = function() {
      var self;
      if (_.size(Transaction.processing) === 0) {
        return this.create();
      } else {
        this.state = 'implicit';
        self = this;
        Transaction.implicit.push(self);
        return Request.ask({
          adapter: this.adapter
        }, self.name)["finally"](function() {
          if (self.state !== 'implicit') {
            return;
          }
          return Transaction.implicit.splice(Transaction.implicit.indexOf(self), 1);
        }).then(function(transaction) {
          if (self.state !== 'implicit') {
            return;
          }
          if (transaction != null) {
            return self.merge(transaction);
          }
          return self.create();
        });
      }
    };

    Transaction.prototype.create = function() {
      var self;
      this.state = 'prepared';
      self = this;
      Transaction.processing[self.name] = self;
      return Promise.using(this.adapter.getRawClient(), function(client) {
        return self.execute(client);
      });

      /*
      return Promise.any([
        (Promise.using adapter.getRawClient(), (client)->
          self.execute(client)),
        requestTransaction(self.name).then (transaction)->
          _ENCLOSING.name = tranaction.name
          return _ENCLOSING
      ]).then (res)->
        if res == _ENCLOSING
          delete Transaction.processing[self.name]
          name = _ENCLOSING.name
          throw new Error(
            "Cannot start top-level transaction in enclosing transaction #{name}")
        return res
       */
    };

    Transaction.prototype.merge = function(enclosingTransaction) {
      var self;
      this.state = 'merged';
      Transaction.logger.debug((this.name.slice(0, 4)) + " MERGE WITH " + (enclosingTransaction.name.slice(0.4)));
      self = this;
      this.isSubtransaction = true;
      return Promise.using(enclosingTransaction.takeClient(this.name), function(client) {
        return self.execute(client);
      });
    };

    Transaction.prototype.execute = function(client) {
      var clientDataAttributes, clientMethods, ref1, self;
      this.state = 'executing';
      self = this;
      ref1 = this.adapter.features.xwrap, clientMethods = ref1.clientMethods, clientDataAttributes = ref1.clientDataAttributes;
      this._client = new AsyncProxyPool([client], clientMethods, clientDataAttributes);
      return self.openTransaction().then(function() {
        var callback;
        callback = Promise.method(self.callback);
        return Request.handle(self, callback.call(self, self), self.adapter.id);
      })["catch"](function(err) {
        return self.rollback().then(function() {
          throw err;
        });
      }).then(function(res) {
        return self.commit().then(function() {
          return res;
        });
      });
    };

    Transaction.prototype.complete = function() {
      var implicit, request, results;
      this.state = 'completed';
      delete Transaction.processing[this.name];
      this._client = null;
      if (_.size(Transaction.processing) > 0) {
        return;
      }
      implicit = Transaction.implicit.shift();
      if (implicit != null) {
        return Request.handleRequest(null, implicit.promise, {
          adapter: this.adapter
        });
      } else {
        results = [];
        while (Transaction.unanswered.length > 0) {
          request = Transaction.unanswered.pop();
          results.push(request.fulfill(null));
        }
        return results;
      }
    };

    Transaction.prototype.openTransaction = function() {
      Transaction.logger.debug("OPEN TR", this.name.slice(0, 4));
      return Promise.using(this.takeClient(this.name), (function(_this) {
        return function(client) {
          Transaction.logger.trace("OPEN: Got client", client.name);
          if (_this.isSubtransaction) {
            if (_this.adapter.features.xwrap.subtransactions) {
              return _this.adapter.openSubTransaction(client, _this.name);
            }
          } else {
            return _this.adapter.openTransaction(client);
          }
        };
      })(this));
    };

    Transaction.prototype.commit = function() {
      return Promise.using(this.takeClient(this.name), (function(_this) {
        return function(client) {
          if (_this.isSubtransaction) {
            if (_this.adapter.features.xwrap.subtransactions) {
              return _this.adapter.commitSubTransaction(client, _this.name);
            }
          } else {
            return _this.adapter.commitTransaction(client);
          }
        };
      })(this))["finally"]((function(_this) {
        return function() {
          return _this.complete();
        };
      })(this));
    };

    Transaction.prototype.rollback = function() {
      return Promise.using(this.takeClient(this.name), (function(_this) {
        return function(client) {
          if (_this.isSubtransaction) {
            if (_this.adapter.features.xwrap.subtransactions) {
              return _this.adapter.rollbackSubTransaction(client, _this.name);
            }
          } else {
            return _this.adapter.rollbackTransaction(client);
          }
        };
      })(this))["finally"]((function(_this) {
        return function() {
          return _this.complete();
        };
      })(this));
    };

    Transaction.prototype.takeClient = function(name) {
      if (this.state !== 'executing') {
        return Promise.reject(new Error('Cannot get client from non-executing transaction.'));
      }
      Transaction.logger.debug('taking client:', name);
      return this._client.use();
    };

    Transaction.prototype.client = function(name) {
      if (this.state !== 'executing') {
        return Promise.reject(new Error('Cannot get client from non-executing transaction.'));
      }
      Transaction.logger.debug('sharing client:', name);
      return this._client.share();
    };

    Request.handleUnanswered = function(request) {
      var check, ref1, ref2;
      if (!((ref1 = request.deferred) != null ? ref1.promise.isPending() : void 0)) {
        Request.logger.debug("unhandled, not pending:", (ref2 = request.name) != null ? ref2 : '????');
        return;
      }
      if (_.size(Transaction.processing) > 0 || Transaction.implicit.length > 0) {
        Transaction.unanswered.push(request);
        if (GLOBAL_TIMEOUT != null) {
          return setTimeout(function() {
            var ref3;
            if ((ref3 = request.deferred) != null ? ref3.promise.isPending() : void 0) {
              Request.logger.error("UNANSWERED TRANSACTION REQUEST");
              return request.reject(new Error("Couldn't handle unanswered transaction request"));
            }
          }, GLOBAL_TIMEOUT);
        } else {
          check = function() {
            return setTimeout(function() {
              var ref3;
              if (!((ref3 = request.deferred) != null ? ref3.promise.isPending() : void 0)) {
                return _.remove(Transaction.unanswered, function(i) {
                  return i === request;
                });
              } else {
                return check();
              }
            }, 1000);
          };
          return check();
        }
      } else {
        Request.logger.debug("no transactions: fulfill with null");
        return request.fulfill(null);
      }
    };

    deathticks = MAX_REQUEST_IN_TRANSACTION / TICKER_REPEAT;

    transactionTicker = function(repeat) {
      var old, tick;
      old = [];
      tick = function() {
        return setTimeout(function() {
          var implicit, processing, requests, str;
          str = function(list) {
            return list.map(function(i) {
              var ref1, ref2;
              return (ref1 = (ref2 = i.name) != null ? ref2.slice(0, 5) : void 0) != null ? ref1 : '????';
            }).join(' ');
          };
          processing = str(_.values(Transaction.processing));
          implicit = str(Transaction.implicit);
          requests = str(Transaction.unanswered);
          Request.logger.info(("Transactions: PRC: " + processing + " ") + ("IMP: " + implicit + " REQ: " + requests));
          Transaction.unanswered.slice().map(function(r, i) {
            var o, oi, ref1;
            if (!((ref1 = r.deferred) != null ? ref1.promise.isPending() : void 0)) {
              Transaction.unanswered.splice(i, 1);
              return;
            }
            oi = _.findIndex(old, function(o) {
              return o.request === r;
            });
            if (oi !== -1) {
              o = old[oi];
              o.ticks += 1;
              if (o.ticks > deathticks) {
                o.request.reject(new Error('Waited too long'));
                return old.splice(oi, 1);
              }
            } else {
              return old.push({
                request: r,
                ticks: 0
              });
            }
          });
          return tick();
        }, repeat);
      };
      return tick();
    };

    transactionTicker(TICKER_REPEAT);

    return Transaction;

  })();

  module.exports = Transaction;

}).call(this);
