// Generated by CoffeeScript 1.9.0
(function() {
  var AsyncPool, Deadlock, MemoryAdapter, MemoryClient, Promise, initialize, label;

  Promise = require('bluebird');

  AsyncPool = require('async-pool');

  label = function() {
    return psbytes(9).then(function(bytes) {
      return bytes.toString('base64');
    });
  };

  Deadlock = (function() {
    function Deadlock(_at_message) {
      this.message = _at_message;
      this.name = "Deadlock";
      Error.captureStackTrace(this, Deadlock);
    }

    return Deadlock;

  })();

  MemoryAdapter = (function() {
    function MemoryAdapter(_at_xwrap, _at_options, _at_insideOf) {
      var i, _ref;
      this.xwrap = _at_xwrap;
      this.options = _at_options;
      this.insideOf = _at_insideOf;
      this.name = options.name;
      this.objects = {};
      this.nclients = (_ref = options.nclients) != null ? _ref : 2;
      this.waiting = [];
      this.transactionsWaiting = {};
      this.clients = AsyncPool((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; 1 <= nclients ? _i <= nclients : _i >= nclients; i = 1 <= nclients ? ++_i : --_i) {
          _results.push(new MemoryClient(this, i));
        }
        return _results;
      }).call(this));
    }

    MemoryAdapter.prototype.get = function(key) {
      var current;
      current = this.objects[key];
      current = this.objects[key];
      if (current(instanceOf(MemoryAdapter))) {
        return current._addWaiting({
          op: 'set',
          transaction: this,
          key: key
        });
      }
      if (this.insideOf != null) {
        return insideOf.get(key).bind(this).then(function(value) {
          this.objects[key] = value;
          return value;
        });
      }
      return Promise.resolve().delay().then(function() {
        return void 0;
      });
    };

    MemoryAdapter.prototype.set = function(key, value) {
      return Promise.resolve().bind(this).then(function() {
        if (this.insideOf != null) {
          return this.insideOf.set(key, this);
        }
      }).then(function() {
        var current;
        current = this.objects[key];
        if (current(instanceOf(MemoryAdapter))) {
          return current._addWaiting({
            op: 'set',
            transaction: this,
            key: key,
            value: value
          });
        } else {
          this.objects[key] = value;
          return Promise.resolve().delay().then(function() {
            return this;
          });
        }
      });
    };

    MemoryAdapter.prototype._addWaiting = function(opHash) {
      var name, transaction, _deadlock;
      transaction = opHash.transaction;
      _deadlock = function() {
        return Promise.throws(new Deadlock(transaction.name + " and " + this.name + " wait for each other"));
      };
      if (transaction.name === this.name) {
        return _deadlock();
      }
      for (name in transaction.transactionsWaiting) {
        if (name === this.name) {
          _deadlock();
        }
      }
      for (name in transaction.transactionsWaiting) {
        this.transactionsWaiting[name] = true;
      }
      this.waiting.push(opHash);
      return Promise.resolve().delay().then(function() {
        return this;
      });
    };

    MemoryAdapter.prototype._releaseWaiting = function() {
      return Promise.resolve(opHash).bind(this).map(function(_arg) {
        var key, op, transaction, value;
        op = _arg.op, key = _arg.key, value = _arg.value, transaction = _arg.transaction;
        return transaction[op](key, value);
      }).then(function() {
        return this;
      });
    };

    MemoryAdapter.prototype.getClient = function() {
      return this.clients.use();
    };

    MemoryAdapter.prototype.openTransaction = function(client, name) {
      var transaction;
      if (name == null) {
        name = this.name + "-" + client.name;
      }
      this.transactions.push = transaction = new MemoryAdapter({
        name: name
      });
      client.transactions.push(transaction);
      return Promise.resolve(this);
    };

    MemoryAdapter.prototype.commitTransaction = function(client) {
      var transaction;
      transaction = client.transactions.pop();
      if (transaction == null) {
        return Promise.resolve(this);
      }
      return Promise.resolve(Object.keys(transaction)).bind(this).map(function(k) {
        return this.set(k, transaction[k]);
      }).then(function() {
        return transaction._releaseWaiting();
      });
    };

    MemoryAdapter.prototype.rollbackTransaction = function(client) {
      var transaction;
      transaction = client.transactions.pop();
      if (transaction == null) {
        return Promise.resolve(this);
      }
      return transaction._releaseWaiting();
    };

    MemoryAdapter.prototype.openSubTransaction = function(client, name) {
      return this.openTransaction(client, name);
    };

    MemoryAdapter.prototype.commitSubTransaction = function(client, name) {
      return this.commitTransaction(client, name);
    };

    MemoryAdapter.prototype.rollbackSubTransaction = function(client, name) {
      return this.commitTransaction(client, name);
    };

    MemoryAdapter.prototype.wrap = function() {
      this.get = function(key) {
        return Promise.using(xwrap.client(), function(client) {
          return client.get(key);
        });
      };
      return this.set = function(key, value) {
        return Promise.using(xwrap.client(), function(client) {
          return client.set(key, value);
        });
      };
    };

    return MemoryAdapter;

  })();

  MemoryClient = (function() {
    function MemoryClient(_at_adapter, _at_n) {
      this.adapter = _at_adapter;
      this.n = _at_n;
      this.transactions = [];
    }

    MemoryClient.prototype.get = function(key) {
      var transaction, value;
      transaction = this.transactions.slice(-1)[0];
      if (transaction != null) {
        return value = transaction.get(key);
      }
    };

    MemoryClient.prototype.set = function(key, value) {
      var transaction, _ref;
      transaction = (_ref = this.transactions.slice(-1)[0]) != null ? _ref : this.adapater;
      return transaction.set(key, value);
    };

    return MemoryClient;

  })();

  initialize = function(xwrap, options) {
    return Promise.resolve(new MemoryAdapter(xwrap, options));
  };

}).call(this);
