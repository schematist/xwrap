// Generated by CoffeeScript 1.9.1
(function() {
  var AsyncPool, Deadlock, MemoryAdapter, MemoryClient, Promise, initialize, label;

  Promise = require('bluebird');

  AsyncPool = require('async-pool');

  label = function() {
    return psbytes(9).then(function(bytes) {
      return bytes.toString('base64');
    });
  };

  Deadlock = (function() {
    function Deadlock(message) {
      this.message = message;
      this.name = "Deadlock";
      Error.captureStackTrace(this, Deadlock);
    }

    return Deadlock;

  })();

  MemoryAdapter = (function() {
    function MemoryAdapter(options1, insideOf1) {
      var i, ref, ref1, ref2;
      this.options = options1;
      this.insideOf = insideOf1;
      this.name = (ref = typeof options !== "undefined" && options !== null ? options.name : void 0) != null ? ref : 'memory';
      this.objects = {};
      this.nclients = (ref1 = (ref2 = this.options) != null ? ref2.nclients : void 0) != null ? ref1 : 2;
      this.waiting = [];
      this.transactionsWaiting = {};
      this.clients = AsyncPool((function() {
        var j, ref3, results;
        results = [];
        for (i = j = 1, ref3 = this.nclients; 1 <= ref3 ? j <= ref3 : j >= ref3; i = 1 <= ref3 ? ++j : --j) {
          results.push(new MemoryClient(this, i));
        }
        return results;
      }).call(this));
    }

    MemoryAdapter.prototype.get = function(key) {
      var current;
      current = this.objects[key];
      current = this.objects[key];
      if (current(instanceOf(MemoryAdapter))) {
        return current._addWaiting({
          op: 'set',
          transaction: this,
          key: key
        });
      }
      if (this.insideOf != null) {
        return insideOf.get(key).bind(this).then(function(value) {
          this.objects[key] = value;
          return value;
        });
      }
      return Promise.resolve().delay().then(function() {
        return void 0;
      });
    };

    MemoryAdapter.prototype.set = function(key, value) {
      return Promise.resolve().bind(this).then(function() {
        if (this.insideOf != null) {
          return this.insideOf.set(key, this);
        }
      }).then(function() {
        var current;
        current = this.objects[key];
        if (current(instanceOf(MemoryAdapter))) {
          return current._addWaiting({
            op: 'set',
            transaction: this,
            key: key,
            value: value
          });
        } else {
          this.objects[key] = value;
          return Promise.resolve().delay().then(function() {
            return this;
          });
        }
      });
    };

    MemoryAdapter.prototype._addWaiting = function(opHash) {
      var _deadlock, name, transaction;
      transaction = opHash.transaction;
      _deadlock = function() {
        return Promise.throws(new Deadlock(transaction.name + " and " + this.name + " wait for each other"));
      };
      if (transaction.name === this.name) {
        return _deadlock();
      }
      for (name in transaction.transactionsWaiting) {
        if (name === this.name) {
          _deadlock();
        }
      }
      for (name in transaction.transactionsWaiting) {
        this.transactionsWaiting[name] = true;
      }
      this.waiting.push(opHash);
      return Promise.resolve().delay().then(function() {
        return this;
      });
    };

    MemoryAdapter.prototype._releaseWaiting = function() {
      return Promise.resolve(opHash).bind(this).map(function(arg) {
        var key, op, transaction, value;
        op = arg.op, key = arg.key, value = arg.value, transaction = arg.transaction;
        return transaction[op](key, value);
      }).then(function() {
        return this;
      });
    };

    MemoryAdapter.prototype.getRawClient = function() {
      return this.clients.use();
    };

    MemoryAdapter.prototype.openTransaction = function(client, name) {
      var transaction;
      if (name == null) {
        name = this.name + "-" + client.name;
      }
      this.transactions.push = transaction = new MemoryAdapter({
        name: name
      });
      client.transactions.push(transaction);
      return Promise.resolve(this);
    };

    MemoryAdapter.prototype.commitTransaction = function(client) {
      var transaction;
      transaction = client.transactions.pop();
      if (transaction == null) {
        return Promise.resolve(this);
      }
      return Promise.resolve(Object.keys(transaction)).bind(this).map(function(k) {
        return this.set(k, transaction[k]);
      }).then(function() {
        return transaction._releaseWaiting();
      });
    };

    MemoryAdapter.prototype.rollbackTransaction = function(client) {
      var transaction;
      transaction = client.transactions.pop();
      if (transaction == null) {
        return Promise.resolve(this);
      }
      return transaction._releaseWaiting();
    };

    MemoryAdapter.prototype.openSubTransaction = function(client, name) {
      return this.openTransaction(client, name);
    };

    MemoryAdapter.prototype.commitSubTransaction = function(client, name) {
      return this.commitTransaction(client, name);
    };

    MemoryAdapter.prototype.rollbackSubTransaction = function(client, name) {
      return this.commitTransaction(client, name);
    };

    MemoryAdapter.prototype.wrap = function() {
      this.get = function(key) {
        return Promise.using(xwrap.client(), function(client) {
          return client.get(key);
        });
      };
      return this.set = function(key, value) {
        return Promise.using(xwrap.client(), function(client) {
          return client.set(key, value);
        });
      };
    };

    return MemoryAdapter;

  })();

  MemoryClient = (function() {
    function MemoryClient(adapter, n) {
      this.adapter = adapter;
      this.n = n;
      this.transactions = [];
    }

    MemoryClient.prototype.get = function(key) {
      var transaction, value;
      transaction = this.transactions.slice(-1)[0];
      if (transaction != null) {
        return value = transaction.get(key);
      }
    };

    MemoryClient.prototype.set = function(key, value) {
      var ref, transaction;
      transaction = (ref = this.transactions.slice(-1)[0]) != null ? ref : this.adapater;
      return transaction.set(key, value);
    };

    return MemoryClient;

  })();

  initialize = function(options) {
    return Promise.resolve(new MemoryAdapter(options));
  };

  exports.initialize = initialize;

}).call(this);
