{"name":"Xwrap","tagline":"Wrap promise-based asynchronous call trees in transactions.","body":"Wrap asynchronous database calls in transactions, using\r\nnodejs and promises.\r\n\r\n# Installation\r\n\r\nnpm install xwrap\r\n\r\n# What it does\r\n\r\nXWrap allows you to use promise-using database tools with transactions\r\nwithout having to pass a transaction object around.\r\n\r\nIf you use a database tool that does not itself use transactions, but:\r\n\r\n1. depends on a database connection package that keeps a pool of clients \r\n(such as [node postgres](https://github.com/brianc/node-postgres)),\r\n\r\n2. Which uses promises that support the progress interface.\r\n\r\nxwrap will let you wrap calls that tool in transactions (and savepoints, if\r\nsupported by the backend) without having to modify the tools.\r\n\r\nIf the tools use xwrap themselves, any transactions they create will\r\nautomatically be converted into savepoints if wrapped by your transactions.\r\n\r\n# Quick Start\r\n\r\n    Promise = require 'bluebird'\r\n    {XRequest, initialize} = require 'xwrap'\r\n    xwrap = initialize(\r\n      'pg', { url: 'postgres://username:password@localhost/database'})\r\n\r\n\r\nThe promise chain in this callback will be wrapped in a transaction\r\nthe three transactions will proceed in parallel on different\r\nclients, or be serialized when the pool runs out of clients.\r\n    \r\n    Promise.map [1..3], ->\r\n      xwrap ->\r\n        foo().then (rows)->\r\n          Promise.map rows, (row, i)->\r\n            bar(row, i)\r\n        .then ->\r\n          # this creates savepoint and then causes error\r\n          baz().catch (err)->\r\n            # error handled here -- savepoint rolled back,\r\n            # but not transaction.\r\n\r\n`foo` can get the appropriate client automatically. `foo` might not be  written\r\nby you and/or the need for the client could be deeply buried, making explicit\r\npassing of client undesirable.\r\n\r\n    foo = ->\r\n      XRequest.client().then (client)->\r\n        client.queryAsync('select * from foo')\r\n      .then ({rows})->\r\n        return rows\r\n\r\nWithin a transaction, calls to `bar` are in parallel, but the client request serializes them. The calls in other transactions proceed unimpeded (modulo\r\nthe database itself, if the transactions hold locks).\r\n\r\n    bar = ->\r\n      XRequest.client().then (client)->\r\n\r\n    baz = ->\r\n      xwrap ->\r\n        # this creates a savepoint; if called outside a transaction\r\n        # it would create a top-level transaction.\r\n        XRequest().client().then (client)->\r\n          ...\r\n          throw new Error('Baz!')\r\n\r\n# Motivation\r\n\r\nSuppose you have been using a package that provides a reporting interface,\r\nor an ORM, etc. If these packages don't use transactions, but use promises\r\nwhich support the progress interface, you can continue using them without \r\nchange.\r\n\r\n# API Documentation\r\n\r\nIn the following, we assume\r\n\r\n    xwrap = require 'xwrap'\r\n\r\n### xwrap(options) -> xtransaction()\r\n\r\nInitializes an xwrap session, passing back function used to wrap promise-\r\nreturning callbacks in  transactions. Xwrap supprts the following options:\r\n\r\n* `adapter`: an adapter or the identifier for an adapter, which   wraps a\r\ndatabase connection. If `adapter` is an object with the `xwrap-adapter`\r\nattribute,  then it is accepted as an adapter. If `adapter` is a string,\r\n`xwrap` tries to load `adapter` package if `adapter` starts with\r\na \"/\", or the `xwrap-adapter` package otherwise. \r\n\r\n* `settings`: settings to initialize the adapter with. If the adapter\r\nis already defined, these are ignored.\r\n\r\n* `id`: optional identifier for the xwrap session. If passed, \r\nthen requests for transactions can also pass `id` to request \r\nID on right session. This mechanism allows multiple xwrap \r\nsessions (say, to multiple databases) to be active \r\nsimultaneously.\r\n\r\n* `wrap`: if `true` (default), and the adapter supports wrapping, the\r\nunderlying database connection will be wrapped. Calls using the database in\r\nthird-party code will retrieve proxies to clients in transactions if there is\r\na wrapping transaction in the call stack above them.\r\n\r\nIf `id` is specified, and there has already been an adapter by\r\nthat `id` defined, the other options are ignored.\r\n\r\nThe module initializer returns the `xtransaction` function, which provides\r\nan interface to transaction for that adapter.\r\n\r\n### xtransaction( [type], callback ) or xtransaction({type, callback, name})\r\n\r\nThe function passed back by `initialize` can be used to wrap\r\nthe activity of a promise-returning callback in a transaction.\r\n\r\nUsed without `type`, xwrap will create a top-level\r\ntransaction if there are no wrapping transactions (belonging\r\nto the same session). Valid types are `xwrap.NEW` or `xwrap.SUB`\r\nfor explicit new and subtransactions.\r\n\r\nThe callback receives a `Transaction` object, which supports `client`\r\nand `takeClient` calls directly.\r\n\r\nPassing a hash allows specification of a name for the transaction,\r\nwhich can be useful for logging and debugging.\r\n\r\nFor convenience, `transaction()` also contains the xwrap interface,\r\nspecialized to the particular adapter. For instance, `transaction.client()`\r\nis the same as `xwrap.client(id)`.\r\n\r\n### xwrap.client([id])\r\n\r\nReturns promise of a shared client in the current transaction, if any is open.\r\nIf there are multiple databases open, `id` can be passed to specify which\r\ndatabase to use.\r\n\r\nNote: a shared client is just a proxy around the client; to serialize\r\nqueries, use `then()` to wait for results before issuing a new query. Parallel use may result in interleaved queries. For example:\r\n\r\n    Promise.map ['A', 'B'], (channel)->\r\n      xwrap.client().then (client)->\r\n        client.query(\"#{channel}1\").then ->\r\n          client.query(\"#{channel}2\")\r\n\r\nMay result in either:\r\n\r\n    A1\r\n    A2\r\n    B1\r\n    B2\r\n\r\nOr \r\n\r\n    A1\r\n    B1\r\n    A2\r\n    B2\r\n\r\nbeing executed. Of course (if the database driver is implemented correctly),\r\nthe right results should be returned to the right callbacks.\r\n\r\nA shared client is useful for calls to third-party\r\n\r\n### xwrap.takeClient([id]) -> Promise with client\r\n\r\nThis will checkout the client any the enclosing transaction\r\n\r\n### xwrap.disconnect([id]) -> Promise\r\n\r\nInstruct adapter to shut down and free underlying resources. Calls\r\nto the xwrap interface after this completes may throw errors. What\r\nhappens to any open transactions is adapter dependent, but most\r\nprobably they will be rolled back.\r\n\r\n### xwrap.wrap([id]) -> Promise\r\n\r\nIf the adapter supports wrapping, the underlying database connection\r\nis wrapped, so that calls to retrieve database clients in 3rd party\r\ncode will retrieve client proxies in any wrapping transaction.\r\n\r\n# Adapters\r\n\r\n`xwrap` depends on a thin adapter around the underlying database,\r\nwhich controls connecting to the database driver, and issuing transaction\r\nstart and stop commands.\r\n\r\nAll adapters must support the basic API, below. The \"subtransaction\"\r\nextension, if present, allows xwrap to create subtransactions. The \"wrap\"\r\nextension, if present, allows xwrap to inject a wrapper to allow all calls\r\nin connected promise chains below xwrap transactions to participate\r\nin transactions.\r\n\r\n## Basic interface\r\n\r\n### initialize(adapterSettings) -> adapter\r\n\r\nThe adapter module should include an `initialize` function,\r\nwhich creates an adapter for the given settings and passes it back\r\nsynchronously.\r\n\r\nAfter creation, xwrap sets the `id` and `xtransaction` attributes\r\nof the adapter.\r\n\r\n### Adapter.features\r\n\r\nA hash, contain the features supported by the adapter. It should have\r\nkey \"xwrap\"; itself a hash containing keys:\r\n\r\n* basic: true if supports basic interface\r\n* subtransactions: true if supports subtransactions\r\n* wrap: true if supports the wrap interface.\r\n* clientMethods: list of method names of clients.\r\n* clientDataAttributes: list of data attributes of clients.\r\n\r\nOn initialization, if or any of the keys first three keys are absent, \r\n`xwrap` will introspect the adapter and guess whether\r\nit supports an API, and set the key itself. `clientMethods` and\r\n`clientDataAttributes` are required in order to create proxies\r\nfor clients for shared access inside of transactions.\r\n\r\n### Adapter.getClient() -> Promise of client\r\n\r\nReturns a [disposer][1] with a checked out database client\r\nfor exclusive use of xwrap.\r\n\r\n[1]: https://github.com/petkaantonov/bluebird/blob/master/API.md#disposerfunction-disposer---disposer)\r\n\r\n### Adapter.openTransaction(client, name) -> Promise of adapter\r\n\r\nIssue command to open a transaction on the client. `xwrap` will pass through a name given by a client, or use a random base64 string if\r\nno name is given. Database adapters often don't need a name to\r\nopen a transaction, but if used, it should be quoted appropriately.\r\n\r\n### Adapter.commitTransaction(client, name) -> Promise of adapter\r\n\r\nIssue command to commit transaction on the client.\r\n\r\n### Adapter.rollbackTransaction(client, name) -> Promise of adapter\r\n\r\nIssue command to rollback transaction on the client.\r\n\r\n### Adapter.disconnect() -> Promise\r\n\r\nDisconnect client and free underlying resources. After this\r\nis called, the adapter may return an error on any other call.\r\n\r\n## Subtransaction Interface\r\n\r\n### Adapter.openSubTransaction(client, name) -> Promise of adapter\r\n\r\nIssue command to open subtransaction with given name on client. `xwrap` will pass through a name given by a client, or use a random base64 string if\r\nno name is given. The command should quote the name appropriately.\r\n\r\n### Adapter.commitSubTransaction(client, name) -> Promise of adapter\r\n\r\nIssue command to commit subtransaction with given name on client. Name\r\nshould be quoted appropriately.\r\n\r\n### Adapter.rollbackSubTransaction(client, name) -> Promise of adapter\r\n\r\nIssue command to rollback subtransaction with given name on client. Name\r\nshould be quoted appropriately.\r\n\r\n## Wrap interface\r\n\r\n### Adapter.wrap(getClientCallback)  -> Promise of adapter\r\n\r\nWraps the underlying client retrieval methods in the database driver,\r\ncalling `getClientCallback` to get a transacction client instead. After\r\nwrapping, other code will be able to participate in transactions opened\r\nabove them in the call stack without needing to interact with `xwrap`,\r\n**as long as they (thuroughly) use transactions.** \r\n\r\n**Warning:** `xwrap` gets its clients from `adapter.getClient()` which\r\nshould maintain its connection to the underlying database regardless of\r\nwrapping.\r\n\r\n\r\n# Promises and Progress\r\n\r\n## OH NO! Progress might be going away! Learn how xwrap works, and why progress is such a good idea.\r\n\r\n# Testing\r\n\r\n    npm test\r\n\r\nwill run mocha on the test files. `test-transactions-stub.litcoffee` tests that `xwrap` wraps\r\ntransactions successfully. `test-transactions.litcoffee` is conceived of as a test that allows\r\nyou to check that your adapter is correctly implemented, and your transactions are really ACID.\r\nIt needs a lot of work to be functional, still -- in particular it needs abstract methods\r\n(instatiated per adapter) to test \"doing something\" with the database, and checking the\r\ndatabase state afterwards.\r\n\r\n# Source Documentation\r\n\r\n* [xwrap](./docs/xwrap.html)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}